#!/bin/bash

# SSH Agent Configuration
# Prefer 1Password SSH agent if available, otherwise fall back to traditional ssh-agent

# 1Password SSH agent socket path (stable across restarts)
# This path is documented by 1Password and matches the IdentityAgent config in ~/.ssh/config
ONEPASSWORD_SSH_AGENT="$HOME/Library/Group Containers/2BUA8C4S2C.com.1password/t/agent.sock"

# If we're in an SSH session, SSH_AUTH_SOCK should be set by agent forwarding
# Don't start a local agent in this case - just trust the forwarded agent
if [ -n "$SSH_CONNECTION" ] && [ -n "$SSH_AUTH_SOCK" ]; then
    # In SSH session with forwarded agent - don't override
    :
elif [ -n "$SSH_AUTH_SOCK" ] && [ -S "$SSH_AUTH_SOCK" ]; then
    # SSH_AUTH_SOCK is already set and the socket exists - keep it
    :
elif [ -S "$ONEPASSWORD_SSH_AGENT" ]; then
    # 1Password is running and SSH agent is available - use it (local machine only)
    export SSH_AUTH_SOCK="$ONEPASSWORD_SSH_AGENT"
elif [ -z "$SSH_CONNECTION" ]; then
    # Not in SSH session and no 1Password - fall back to traditional ssh-agent
    # Store agent info in a persistent file so all shells can share the same agent
    SSH_ENV="$HOME/.ssh/agent-env"

    start_agent() {
        ssh-agent -s > "$SSH_ENV"
        chmod 600 "$SSH_ENV"
        . "$SSH_ENV" > /dev/null
    }

    # Check if we can connect to an existing agent
    if [ -f "$SSH_ENV" ]; then
        . "$SSH_ENV" > /dev/null
        # Verify the socket actually exists and the agent is running
        if [ ! -S "$SSH_AUTH_SOCK" ] || ! kill -0 "$SSH_AGENT_PID" 2>/dev/null; then
            # Agent is dead or socket is stale, start a new one
            start_agent
        fi
    else
        # No agent file exists, start a new one
        start_agent
    fi
fi

# Source shared shell functions
[ -r "$HOME/.files/sh/functions" ] && . "$HOME/.files/sh/functions"

[ -r /usr/local/etc/profile.d/autojump.sh ] && . /usr/local/etc/profile.d/autojump.sh
[ -r /usr/local/etc/profile.d/z.sh ] && . /usr/local/etc/profile.d/z.sh
# macos
[ -r /usr/local/opt/chruby/share/chruby/chruby.sh ] && . /usr/local/opt/chruby/share/chruby/chruby.sh
# arch
[ -r /usr/share/chruby/chruby.sh ] && . /usr/share/chruby/chruby.sh

# macos
[ -r /usr/local/opt/chruby/share/chruby/auto.sh ] && . /usr/local/opt/chruby/share/chruby/auto.sh
# arch
[ -r /usr/share/chruby/auto.sh ] && . /usr/share/chruby/auto.sh

# Lazy load rbenv - add shims to PATH but defer full initialization
if command -v rbenv >/dev/null; then
	export PATH="$HOME/.rbenv/shims:$PATH"
	# Only fully initialize rbenv when the command is actually used
	rbenv() {
		unset -f rbenv
		eval "$(command rbenv init -)"
		rbenv "$@"
	}
fi

export OS=$(uname -s)
export EDITOR="vim"
export PAGER="less"
# -X or --no-init
# -F or --quit-if-one-screen
# -M or --LONG-PROMPT
# -I or --IGNORE-CASE
# -n or --line-numbers: no line numbers
# -R or --RAW-CONTROL-CHARSLike -r, but only ANSI "color" escape sequences and OSC 8 hyperlink sequences are output in "raw" form.
export LESS="-XRFMIn"
export ARCH=$(uname -m)
export IRCNICK='lanej'
export IRCSERVER='irc.freenode.net'
export EDITORD=${EDITORD:-$EDITOR}
# nord-ish
export JQ_COLORS="1;37:0;31:0;35:0;36:0;32:1;37:1;37"
export XDG_CONFIG_HOME="$HOME/.config"
export GIT_SSH="$HOME/.local/bin/git-ssh"

if [[ $OSTYPE =~ 'darwin' ]]; then
	export GPG_TTY=$(tty)
fi

if [ -d "$XDG_CONFIG_HOME/yarn/global/node_modules/.bin" ]; then
	export PATH="$XDG_CONFIG_HOME/yarn/global/node_modules/.bin:$PATH"
fi

if [ -d "$HOME/.yarn/bin" ]; then
	export PATH="$HOME/.yarn/bin:$PATH"
fi

if [ -d "$HOME/.luarocks/bin" ]; then
	export PATH="$HOME/.luarocks/bin:$PATH"
fi

if [ -r "$HOME/.env" ]; then
	. "$HOME/.env"
fi

# Set RUSTC_WRAPPER to sccache if installed and not already set
if [ -z "$RUSTC_WRAPPER" ] && command -v sccache >/dev/null 2>&1; then
	export RUSTC_WRAPPER=sccache
fi

test -r "~/.dir_colors" && eval $(dircolors ~/.dir_colors)

export SKIM_DEFAULT_COMMAND="fd --type f || git ls-tree -r --name-only HEAD || rg --files || find ."

if [ -s "${HOME}/.gvm/scripts/gvm" ]; then
	. "${HOME}/.gvm/scripts/gvm"
else
	if [ -d "/opt/golang1.23/bin" ]; then
		export PATH="/opt/golang1.23/bin:$PATH"
	fi

	export GOPATH="$HOME"/.local/go
fi

if [ -d "$GOPATH" ]; then
	export PATH="$GOPATH/bin:$PATH"
fi

if [ -d "/opt/homebrew" ]; then
	export PATH="/opt/homebrew/bin:$PATH"
	export PATH="/opt/homebrew/sbin:$PATH"
	# Cache brew shellenv output instead of running it every time (saves ~40ms)
	export HOMEBREW_PREFIX="/opt/homebrew"
	export HOMEBREW_CELLAR="/opt/homebrew/Cellar"
	export HOMEBREW_REPOSITORY="/opt/homebrew"
	export MANPATH="/opt/homebrew/share/man${MANPATH+:$MANPATH}:"
	export INFOPATH="/opt/homebrew/share/info:${INFOPATH:-}"
fi

if [ -r "${HOME}/.nvm/alias/default" ]; then
	# find the prescribed default node version
	default_node_version=$(cat "${HOME}/.nvm/alias/default")
	# expand the path to the default node version without nvm
	default_node_bin_path=(${HOME}/.nvm/versions/node/v${default_node_version}*/bin)
	export PATH="${default_node_bin_path}:${PATH}"
fi


if [[ -d "$HOME/.local/bin" ]]; then
	PATH="$HOME/.local/bin:$PATH"
fi

if [[ -r "$HOME/.cargo/env" ]]; then
	. "$HOME/.cargo/env"
fi

if [[ -r "$HOME/.dotnet/tools" ]]; then
	PATH="$HOME/.dotnet/tools:$PATH"
fi

# NOTE: Set EDITOR/VISUAL after all PATH modifications are complete
unset EDITOR
unset VISUAL

if command -v nvim >/dev/null; then
	export EDITOR="$(command -v nvim)"
	export VISUAL="$(command -v nvim)"
elif command -v vim >/dev/null; then
	export EDITOR="$(command -v vim)"
	export VISUAL="$(command -v vim)"
else
	export EDITOR=vi
	export VISUAL=vi
fi
