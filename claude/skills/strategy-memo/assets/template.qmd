---
# ─────────────────────────────────────────────────────────────────────────────
# STRATEGY MEMO TEMPLATE
# Generated by the strategy-memo skill.
# Replace all {{PLACEHOLDER}} tokens before rendering.
#
# Build commands (requires Justfile in project root):
#   just render          — PDF + HTML + check + Drive sync
#   just preview         — HTML only, opens in browser
#   just preview-fig fig1 — Screenshot a single figure (~15s)
#   just check           — Scan PDF for unrendered Python literals
#   just delete-cache    — Wipe data/cache/ to force live re-query
# ─────────────────────────────────────────────────────────────────────────────
format:
  pdf:
    documentclass: article
    fontsize: 11pt
    geometry: margin=1in
    number-sections: false
    colorlinks: true
    fig-pos: "htbp"
    keep-tex: false
    pdf-engine: lualatex
    include-in-header:
      text: |
        \usepackage{needspace}
        \usepackage{booktabs}
        \usepackage{fancyhdr}
        \usepackage{float}
        \usepackage{microtype}
        \usepackage{caption}
        \captionsetup{font={small,it},justification=centering,skip=6pt}
        \pagestyle{fancy}
        \fancyhead[L]{\small\itshape {{COMPANY_NAME}} Confidential}
        \fancyhead[R]{\small\itshape {{DOCUMENT_TITLE_SHORT}}}
        \fancyfoot[C]{\thepage}
    include-before-body:
      text: |
        \thispagestyle{empty}
  html:
    theme: none
    minimal: true
    page-layout: article
    toc: false
    number-sections: false
    fig-width: 9
    fig-height: 4.5
    self-contained: true
execute:
  cache: false   # Using explicit file-based cache (data/cache/) — not Jupyter cache
  freeze: true
  echo: false
  warning: false
---

```{=latex}
% ── Document header ──────────────────────────────────────────────────────────
% Title bar: document title left, author + date right. No \maketitle.
\begin{minipage}[t]{0.65\textwidth}
  {\large\textbf{{{DOCUMENT_TITLE}}}} \\[2pt]
  {\small\itshape {{DOCUMENT_SUBTITLE}}}
\end{minipage}%
\begin{minipage}[t]{0.35\textwidth}
  \raggedleft{\small {{AUTHOR_NAME}} · {{MONTH_YEAR}}}
\end{minipage}
\vspace{3pt}
\hrule
\vspace{10pt}
```

```{python}
#| label: setup
#| include: false
# ─────────────────────────────────────────────────────────────────────────────
# SETUP CELL — run once, shared across all cells
# ─────────────────────────────────────────────────────────────────────────────
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import matplotlib.ticker as mticker
import subprocess
import json
import os
import warnings
warnings.filterwarnings('ignore')

# ── Optional: set GCP project for BigQuery CLI ────────────────────────────────
# os.environ['GOOGLE_CLOUD_PROJECT'] = '{{GCP_PROJECT_ID}}'

# Ensure ~/.local/bin (where `bigquery` CLI lives) is on PATH
local_bin = os.path.expanduser('~/.local/bin')
if local_bin not in os.environ.get('PATH', ''):
    os.environ['PATH'] = local_bin + ':' + os.environ.get('PATH', '')

# ── Color palette ─────────────────────────────────────────────────────────────
# Reference these constants in all figure cells. Never hardcode hex values.
NAVY       = '#1e3a5f'
TEAL       = '#0d9488'
CORAL      = '#e63946'
SLATE      = '#475569'
LIGHT_SLATE = '#94a3b8'
GOLD       = '#d97706'
WHITE      = '#ffffff'
LIGHT_BG   = '#f8fafc'

# ── Global matplotlib style ───────────────────────────────────────────────────
plt.rcParams.update({
    'font.family': 'sans-serif',
    'font.sans-serif': ['Helvetica Neue', 'Arial', 'DejaVu Sans'],
    'font.size': 9,
    'axes.titlesize': 10,
    'axes.titleweight': 'bold',
    'axes.labelsize': 8,
    'axes.labelcolor': SLATE,
    'axes.edgecolor': LIGHT_SLATE,
    'axes.linewidth': 0.5,
    'xtick.labelsize': 8,
    'ytick.labelsize': 8,
    'xtick.color': SLATE,
    'ytick.color': SLATE,
    'figure.dpi': 200,
    'savefig.dpi': 300,
    'savefig.bbox': None,        # fills declared figsize exactly — do NOT set to 'tight'
    'savefig.pad_inches': 0,
    'axes.spines.top': False,
    'axes.spines.right': False,
    'axes.grid': False,
    'figure.facecolor': WHITE,
    'axes.facecolor': WHITE,
})

# ── BigQuery helper ───────────────────────────────────────────────────────────
def run_bq_query(query: str, max_results: int = 10000) -> pd.DataFrame:
    """Execute BigQuery query via CLI and return DataFrame.
    Raises on error or empty result — no silent fallback.
    """
    result = subprocess.run(
        ['bigquery', 'query', '--yes', '--max-results', str(max_results), query],
        capture_output=True, text=True
    )
    if result.returncode != 0:
        raise Exception(f"BigQuery error: {result.stderr}")
    data = json.loads(result.stdout)
    rows = data.get('rows')
    if not rows:
        raise Exception(f"No rows returned for query")
    return pd.DataFrame(rows)
```

```{python}
#| label: key-numbers
#| include: false
# ─────────────────────────────────────────────────────────────────────────────
# KEY NUMBERS CELL
# All authoritative figures are derived here from live BigQuery queries.
#
# Pattern: cache-read-or-query (mandatory — no fallback constants)
#   - Cache hit  → reads DataFrame and scalars from JSON, no BigQuery call
#   - Cache miss → queries BigQuery live, writes cache, continues render
#   - Query fail → render fails loudly (intentional — no silent fallback)
#
# Wipe cache with: just delete-cache
# ─────────────────────────────────────────────────────────────────────────────
from pathlib import Path
from datetime import datetime, timezone

_CACHE_DIR = Path('data/cache')
_CACHE_DIR.mkdir(parents=True, exist_ok=True)

def _cache_path(name):
    return _CACHE_DIR / f"{name}.json"

def _read_cache(name):
    p = _cache_path(name)
    if p.exists():
        return json.loads(p.read_text())
    return None

def _write_cache(name, records, scalars=None):
    p = _cache_path(name)
    p.write_text(json.dumps({
        '_queried_at': datetime.now(timezone.utc).isoformat(),
        'records': records,
        'scalars': scalars or {}
    }, default=str))

# ─────────────────────────────────────────────────────────────────────────────
# EXAMPLE DATASET — replace with your actual queries
# Copy this pattern for each additional data source.
# ─────────────────────────────────────────────────────────────────────────────

# Replace this query with your actual SQL
_example_query = """
SELECT
  'example' AS label,
  COUNT(*) AS record_count
FROM `{{GCP_PROJECT_ID}}.{{DATASET}}.{{TABLE}}`
WHERE created_at >= '{{START_DATE}}'
"""

_c = _read_cache('example_dataset')
if _c:
    df_example      = pd.DataFrame(_c['records'])
    example_count   = int(_c['scalars']['example_count'])
    example_label   = str(_c['scalars']['example_label'])
else:
    df_example      = run_bq_query(_example_query)
    example_count   = int(float(df_example['record_count'].values[0]))
    example_label   = str(df_example['label'].values[0])
    _write_cache('example_dataset', df_example.to_dict(orient='records'), {
        'example_count': example_count,
        'example_label': example_label,
    })

# TODO: Add additional data blocks following the same pattern:
#
# _c = _read_cache('dataset_name')
# if _c:
#     df_xyz      = pd.DataFrame(_c['records'])
#     df_xyz['col'] = pd.to_numeric(df_xyz['col'])
#     my_scalar   = float(_c['scalars']['my_scalar'])
# else:
#     df_xyz      = run_bq_query(xyz_query)
#     df_xyz['col'] = pd.to_numeric(df_xyz['col'])
#     my_scalar   = float(df_xyz['col'].values[0])
#     _write_cache('dataset_name', df_xyz.to_dict(orient='records'), {
#         'my_scalar': my_scalar,
#     })
```

{{OPENING_PARAGRAPH}}

{{CONTEXT_AND_STAKES}}

My role is to provide direction. Your role is to ensure that direction is correct, then design the coherent actions to execute it.

## How These Sessions Work

**Session 1 pressure-tests the guiding policy**. I present the challenge and the evidence. You bring your technical competence and domain expertise to challenge the diagnosis, the policy, and the logic connecting them. If there are fatal flaws, alternative framings, or critical gaps---that is what Session 1 surfaces.

**Session 2 designs coherent actions**. Once we have validated the policy together, we identify the initiatives required to execute it, sequence their dependencies, and make explicit commitments on what each team owns and what stops.

Your role is to make this strategy better before we commit to it.

\newpage

# Part 1: The Situation

{{SITUATION_OPENING_PARAGRAPH}}

\begin{quote}
\small\itshape
"{{CUSTOMER_OR_EVIDENCE_QUOTE}}"

\upshape---{{ATTRIBUTION}}, {{ATTRIBUTION_DATE}}
\end{quote}

{{SITUATION_ANALYSIS_PROSE}}

```{python}
#| label: fig-situation
#| fig-cap: "{{SITUATION_FIGURE_CAPTION_INSIGHT_FOCUSED}}"
#| fig-height: 4.0
#| fig-width: 6.5
#| fig-pos: "H"
#| out-width: 100%
# ─────────────────────────────────────────────────────────────────────────────
# PRIMARY SITUATION FIGURE
# Show the core diagnosis visually — the reader should not need the prose
# to understand the problem after seeing this figure.
#
# LABEL OVERLAP PREVENTION (verified against PDF render):
#   - Use short x-axis labels (4–8 chars max). Parenthetical sub-labels
#     (e.g. "Gateway A\n(Auth Platform)") crowd at 4+ categories.
#   - For multi-metric comparisons, use 3 separate panels (1 metric each)
#     instead of dual y-axes. Dual-axis annotations collide in PDF.
#   - After placing any ax.text() label, call t.set_clip_on(True) to
#     prevent bbox expansion that causes "comically small" PDF figures.
#   - Use fig.subplots_adjust() instead of plt.tight_layout() when panels
#     have secondary y-axes or right-side legends — tight_layout underestimates
#     the right margin needed.
#   - Highlight the single outlier bar in CORAL; leave others LIGHT_SLATE.
#     This makes the problem visible without needing annotations to compete.
#
# Common patterns for situation figures:
#   - 3-panel bar (volume | error rate | latency) — clean, no overlaps
#   - Sankey (deal flow, money flow, customer journey) — from pre-read.qmd
#   - Stacked bar (composition over time) — see fig-incident-cost example
#   - Waterfall (YoY revenue delta by stream) — see pre-read.qmd Part 1
#   - Line chart with annotated events (inflection points)
# ─────────────────────────────────────────────────────────────────────────────

fig, ax = plt.subplots(figsize=(6.5, 4.0))

# --- placeholder: replace with real chart ---
ax.text(0.5, 0.5, 'Figure 1: Situation\n(TODO: implement)',
        ha='center', va='center', fontsize=14, color=SLATE,
        transform=ax.transAxes)
ax.set_axis_off()
# -------------------------------------------

plt.show()
plt.close('all')
```

{{SITUATION_CONTINUATION_PROSE}}

\newpage

# Part 2: Why This Intent

{{PART2_OPENING}}

{{PART2_STRATEGIC_RATIONALE}}

```{python}
#| label: fig-evidence
#| fig-cap: "{{EVIDENCE_FIGURE_CAPTION}}"
#| fig-height: 3.5
#| fig-width: 6.5
#| fig-pos: "H"
#| out-width: 100%
# ─────────────────────────────────────────────────────────────────────────────
# EVIDENCE FIGURE
# The data that makes the strategic rationale credible.
# Typical: revenue trend, market position, unit economics, moat metric.
# ─────────────────────────────────────────────────────────────────────────────

fig, ax = plt.subplots(figsize=(6.5, 3.5))

# --- placeholder: replace with real chart ---
ax.text(0.5, 0.5, 'Figure 2: Evidence\n(TODO: implement)',
        ha='center', va='center', fontsize=14, color=SLATE,
        transform=ax.transAxes)
ax.set_axis_off()
# -------------------------------------------

plt.tight_layout()
plt.show()
plt.close('all')
```

{{PART2_CONTINUATION}}

\newpage

# Part 3: What This Requires

{{PART3_OPENING}}

## Technical Competence

{{PART3_TECHNICAL}}

## Organizational Clarity

{{PART3_ORGANIZATIONAL}}

## Execution Discipline

{{PART3_EXECUTION}}

```{python}
#| label: fig-dependencies
#| fig-cap: "{{DEPENDENCIES_FIGURE_CAPTION}}"
#| fig-height: 3.5
#| fig-width: 6.5
#| fig-pos: "H"
#| out-width: 100%
# ─────────────────────────────────────────────────────────────────────────────
# DEPENDENCIES / REQUIREMENTS FIGURE (optional — delete if not needed)
# Common patterns: capability spine diagram, timeline, maturity matrix.
# ─────────────────────────────────────────────────────────────────────────────

fig, ax = plt.subplots(figsize=(6.5, 3.5))

# --- placeholder: replace with real chart ---
ax.text(0.5, 0.5, 'Figure 3: Dependencies\n(TODO: implement)',
        ha='center', va='center', fontsize=14, color=SLATE,
        transform=ax.transAxes)
ax.set_axis_off()
# -------------------------------------------

plt.tight_layout()
plt.show()
plt.close('all')
```

\newpage

# Part 4: Questions to Refine Intent

The following are the strategic choices this document does not resolve. Session 1 surfaces which are wrong; Session 2 decides them.

**1. {{STRATEGIC_QUESTION_1}}**

{{QUESTION_1_FRAMING}}

**2. {{STRATEGIC_QUESTION_2}}**

{{QUESTION_2_FRAMING}}

**3. {{STRATEGIC_QUESTION_3}}**

{{QUESTION_3_FRAMING}}

**4. {{STRATEGIC_QUESTION_4}}**

{{QUESTION_4_FRAMING}}

**5. {{STRATEGIC_QUESTION_5}}**

{{QUESTION_5_FRAMING}}
